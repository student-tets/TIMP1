
# Бинарный поиск
# есть список чисел от 1 до 10
lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# найти позицию элемента n
n = 11

# Вариант 1 - идем поэтапно
# 1. берем следующий элемент
# 2. если текущий элемент равен n:
# 3.     мы нашли позицию n. Ура!!!
# 4. иначе если текущий элемент не равен n:
# 5.     возвращаемся на шаг 1
# 6. иначе:
# 7.     элемента n нет в списке lst
# Худший случай: Big O(n)

# Вариант 2 - банарный поиск
# 1. Зададим границы: low = 0, high = максимальное значение списка lst
# 2. Складываем границу low и high и делим пополам
#         guess = (low + high) // 2
# 2. если lst[guess] == n (если элемент этой позиции соответствует элементу n):
# 3.     мы нашли позицию n. Ура!!!
# 4. иначе если lst[guess] < n:
# 5.     high = guess - 1 (меняем вехнюю границу на guess без крайнего элемента)
# 6.     возвращаемся на шаг 2
# 7. иначе если lst[guess] > n:
# 8.     low = guess + 1 (меняем нижнюю границу на guess без просмотренного элемента)
# 9.     возвращаемся на шаг 2
# 8. иначе:
# 9.     элемента n нет в списке lst
# Худший случай: Big O(log n)

